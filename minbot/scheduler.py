"""Periodic issue checking and proactive suggestions."""

import json
import logging
import os
import random
import traceback
from pathlib import Path
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from minbot import github, agent


log = logging.getLogger(__name__)
_scheduler = None
_KNOWN_ISSUES_PATH = Path.home() / ".minbot" / "known_issues.json"


def _load_known_issues() -> dict[str, set[int]]:
    if _KNOWN_ISSUES_PATH.exists():
        data = json.loads(_KNOWN_ISSUES_PATH.read_text())
        return {repo: set(nums) for repo, nums in data.items()}
    return {}


def _save_known_issues(known: dict[str, set[int]]) -> None:
    data = {repo: sorted(nums) for repo, nums in known.items()}
    _KNOWN_ISSUES_PATH.write_text(json.dumps(data))


async def _check_issues(config, send_message):
    """Check for new issues across all repos and notify via Telegram."""
    try:
        known = _load_known_issues()
        found_new = False

        for repo in config.github_repos:
            issues = github.list_issues(repo, include_prs=False)
            current = {i["number"] for i in issues}
            prev = known.get(repo, set())
            new_numbers = current - prev

            if repo in known and new_numbers:
                found_new = True
                new_issues = [i for i in issues if i["number"] in new_numbers]
                text = f"New issues in {repo}:\n\n"
                for i in new_issues:
                    labels = ", ".join(i["labels"]) if i["labels"] else ""
                    text += f"#{i['number']} {i['title']}"
                    if labels:
                        text += f" [{labels}]"
                    text += "\n"
                await send_message(text)

            known[repo] = current

        _save_known_issues(known)

        if not found_new:
            await send_message("Issue check: no new issues.")
    except Exception as e:
        log.error("Issue check failed: %s", traceback.format_exc())
        await send_message(f"Issue check failed: {e}")


async def _send_suggestions(config, send_message):
    """Proactively suggest what to work on next across all repos."""
    try:
        all_analyzed = []
        for repo in config.github_repos:
            try:
                all_items = github.list_issues(repo, include_prs=True)
                issues = [i for i in all_items if not i["is_pr"]]
                prs = [i for i in all_items if i["is_pr"]]
                analyzed = agent.analyze_issues(issues, config.anthropic_api_key, prs)
                for a in analyzed:
                    a["repo"] = repo
                all_analyzed.extend(analyzed)
            except Exception as e:
                log.error("Failed to analyze %s: %s", repo, e)
                await send_message(f"Failed to analyze {repo}: {e}")

        if not all_analyzed:
            await send_message("No open issues to suggest.")
            return

        suggestion = agent.suggest_next(all_analyzed, config.anthropic_api_key)
        await send_message(f"Work suggestion:\n\n{suggestion}")
    except Exception as e:
        log.error("Suggestion failed: %s", traceback.format_exc())
        await send_message(f"Suggestion failed: {e}")


async def _review_code(config, send_message):
    """Periodic code review: randomly review codebase or an open PR.

    Codebase review: creates GitHub issues for each suggestion.
    PR review: runs Claude on the PR branch, posts review as a comment.
    """
    try:
        for repo in config.github_repos:
            try:
                # 70% chance to review a PR, 30% to review codebase
                do_pr_review = random.random() < 0.7
                prs = github.list_prs(repo) if do_pr_review else []

                if prs:
                    pr_info = random.choice(prs)
                    pr = github.get_pr(repo, pr_info["number"])
                    comments = github.get_pr_comments(repo, pr_info["number"])
                    repo_path = os.path.join(config.workspace_dir, repo)
                    github.clone_repo(repo, repo_path)
                    github.checkout_pr_branch(repo_path, pr["branch"])
                    review = agent.review_pr(pr, comments, repo_path, config.anthropic_api_key)
                    comment_body = (
                        f"**Automated code review by minbot**\n\n"
                        f"{review}\n\n"
                        f"---\n"
                        f"_Generated by [minbot](https://github.com/ChicagoHAI/minbot)_"
                    )
                    github.add_pr_comment(repo, pr["number"], comment_body)
                    await send_message(
                        f"PR Review — {repo} #{pr['number']}: {pr['title']}\n\n"
                        f"Posted review comment on the PR.\n\n{review[:3000]}"
                    )
                else:
                    repo_path = os.path.join(config.workspace_dir, repo)
                    github.clone_repo(repo, repo_path)
                    existing = github.list_issues(repo, include_prs=False)
                    suggestions = agent.review_codebase(repo_path, existing, config.anthropic_api_key)
                    if not suggestions:
                        await send_message(f"Code Review — {repo}: no suggestions.")
                        continue
                    created = []
                    for s in suggestions:
                        body = (
                            f"{s['body']}\n\n"
                            f"---\n"
                            f"_Identified by [minbot](https://github.com/ChicagoHAI/minbot) code review_"
                        )
                        url = github.create_issue(repo, s["title"], body)
                        created.append(f"- {s['title']}: {url}")
                    await send_message(
                        f"Code Review — {repo}\n\n"
                        f"Created {len(created)} issue(s):\n" + "\n".join(created)
                    )
            except Exception as e:
                log.error("Review failed for %s: %s", repo, traceback.format_exc())
                await send_message(f"Review failed for {repo}: {e}")
    except Exception as e:
        log.error("Review job failed: %s", traceback.format_exc())
        await send_message(f"Review job failed: {e}")


def start(config, send_message) -> AsyncIOScheduler:
    """Start the periodic issue checker and suggestion jobs."""
    global _scheduler
    _scheduler = AsyncIOScheduler(job_defaults={"misfire_grace_time": 3600})
    _scheduler.add_job(
        _check_issues, "interval",
        hours=config.check_interval_hours,
        args=[config, send_message],
    )
    _scheduler.add_job(
        _send_suggestions, "interval",
        hours=config.suggest_interval_hours,
        args=[config, send_message],
    )
    if config.review_interval_hours:
        _scheduler.add_job(
            _review_code, "interval",
            hours=config.review_interval_hours,
            args=[config, send_message],
        )
    # Run both immediately on startup
    _scheduler.add_job(_check_issues, args=[config, send_message])
    _scheduler.add_job(_send_suggestions, args=[config, send_message])
    _scheduler.start()
    return _scheduler


def stop():
    global _scheduler
    if _scheduler:
        _scheduler.shutdown(wait=False)
        _scheduler = None
